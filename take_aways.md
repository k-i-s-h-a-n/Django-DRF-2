# Differences Between PUT and PATCH:
PUT: Replaces the entire resource. Missing fields will be replaced with null or default values.
PATCH: Updates only the provided fields, leaving others unchanged. Use partial=True in the serializer.


# What is @api_view?
@api_view is a decorator used in DRF to specify which HTTP methods a function-based view should respond to. It ensures that your view will only handle the allowed methods (e.g., GET, POST, PUT, etc.)

# DECORATOR
A decorator in Python is a special function that modifies the behavior of another function or class. Think of it as a way to "add extra features" to a function without changing its original code.

Simple Explanation
Imagine a cake (function) that you want to decorate (add extra toppings).
The decorator is like the icing or sprinkles you add on top of the cake.
The cake remains the same inside, but now it looks and tastes better.


# Serializer
In Django REST Framework (DRF), a serializer is a tool that converts complex data types, like Django models, into Python data types (such as dictionaries) or JSON format, which can be easily rendered into a response. It can also do the reverse—convert validated data back into complex data types, like Django model instances.

1. Serialization: Converting model data into JSON.
# Example view to serialize data
from rest_framework.response import Response
from .models import Person

def get_person_data(request):
    person = Person.objects.first()  # Fetch a person instance
    serializer = PersonSerializer(person)  # Serialize the instance
    return Response(serializer.data)  # Returns JSON
{
    "id": 1,
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
}


2. Deserialization: Converting JSON into Python data.
data = {
    "name": "Bob",
    "age": 25,
    "email": "bob@example.com"
}
serializer = PersonSerializer(data=data)  # Deserialize the JSON
if serializer.is_valid():
    person = serializer.save()  # Save it as a new Person instance



# what is serializers.Serializer and serializers.ModelSerializer ?

serializers.Serializer:
    Manual Control: You define each field and validation logic manually.
    Not Tied to a Model: Works for any data, not just models.
    More Flexible: Useful when you need custom serialization or don't have a model.
Example:
    from rest_framework import serializers
    class PersonSerializer(serializers.Serializer):
        name = serializers.CharField(max_length=100)
        age = serializers.IntegerField()
        email = serializers.EmailField()


serializers.ModelSerializer
    Automatic Setup: Automatically generates fields and validation based on a model.
    Model Tied: Designed for use with Django models.
    Less Work: Quicker for model-related serializers.
EXAPMLE:
    from rest_framework import serializers
    from .models import Person

    class PersonSerializer(serializers.ModelSerializer):
        class Meta:
            model = Person  # Specify the model
            fields = ['id', 'name', 'age', 'email']  # Include these fields


Key Difference:
serializers.Serializer: Full manual control, more flexible.
serializers.ModelSerializer: Simplified, built directly on a Django model.




# Depth
In Django REST Framework (DRF), the depth option in a serializer's Meta class controls how deeply the serializer should include related objects.


# SerializerMethodField
In Django REST Framework (DRF), SerializerMethodField is a special field that lets you define a custom method in your serializer to calculate or modify the value of that field.

-Key Features:
    It's read-only (used for displaying data, not writing).
    The value is generated by a method in the serializer.
    from rest_framework import serializers

    class PersonSerializer(serializers.Serializer):
        name = serializers.CharField()
        age = serializers.IntegerField()
        is_adult = serializers.SerializerMethodField()  # Custom field

        def get_is_adult(self, obj):
            return obj.age >= 18  # Custom logic
output:-        
{
    "name": "Alice",
    "age": 20,
    "is_adult": true
}


# Difference between @api_view and ApiView

In Django REST Framework (DRF), both @api_view decorator and APIView class are used to handle API requests, but they are used in different ways.

1. @api_view Decorator:
Function-based views: It’s used with regular Python functions to specify which HTTP methods (GET, POST, etc.) the function should handle.
Simple and quick: Ideal for simple or small views where you don’t need the full flexibility of class-based views.
        from rest_framework.decorators import api_view
        from rest_framework.response import Response

        @api_view(['GET'])
        def my_view(request):
            return Response({"message": "Hello, world!"})

2. APIView Class:
Class-based views: It’s used to define views as classes, providing more structure and flexibility.
More control: Ideal for complex views where you want to handle multiple HTTP methods, apply permissions, or add extra logic in different methods (e.g., get(), post()).

        from rest_framework.views import APIView
        from rest_framework.response import Response

        class MyView(APIView):
            def get(self, request):
                return Response({"message": "Hello, world!"})


Key Differences:
@api_view is for function-based views (quick, less structure).
APIView is for class-based views (more control, structure).




# ModelViewSet
In Django REST Framework (DRF), a ModelViewSet is a class-based view that provides CRUD operations (Create, Read, Update, Delete) for a specific model, without needing to write the logic for each operation manually.

Key Features:
Automatic: It automatically provides behavior for common actions (list, retrieve, create, update, delete).
Simplified: You don't need to manually define each view for CRUD actions.


        from rest_framework import viewsets
        from .models import Person
        from .serializers import PersonSerializer

        class PersonViewSet(viewsets.ModelViewSet):
            queryset = Person.objects.all()  # Define which model to work with
            serializer_class = PersonSerializer  # Define the serializer for the model

    How It Works:
        ModelViewSet uses the model and serializer to automatically handle requests.
        GET: List or retrieve objects.
        POST: Create a new object.
        PUT/PATCH: Update an existing object.
        DELETE: Remove an object.

    In your urls.py, you typically use router to automatically generate URLs for the ModelViewSet:
        from rest_framework.routers import DefaultRouter
        from .views import PersonViewSet

        router = DefaultRouter()
        router.register(r'persons', PersonViewSet)

        urlpatterns = router.urls